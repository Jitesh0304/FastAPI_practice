from datetime import datetime, timedelta, timezone
# from typing import Annotated
import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext
from pydantic import BaseModel

"""
With passlib, you could even configure it to be able to read passwords created by Django, a Flask security 
plug-in or many others.

So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI 
application. Or gradually migrate a Django application using the same database.

pip install pyjwt
pip install passlib
pip install bcrypt==4.0.0

And your users would be able to login from your Django app or from your FastAPI app, at the same time.

The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones 
only to allow verifying them, etc.

For example, you could use it to read and verify passwords generated by another system (like Django) but hash 
any new passwords with a different algorithm like Bcrypt
"""


# we use secrete key to encode and decode JWT token
SECRET_KEY = "fastAPIspecialsecretekeyfordevelopment"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


# create a dictionary with fave data ... convert the password into hash_password
fake_users_db = {
    "alpha": {
        "username": "alpha",
        "full_name": "alpha xyz",
        "email": "alpha@gmail.com",
        "hashed_password": "$2b$12$VFqkdO..7NFl7UHIFqckjePnAglZaP9Iq1z9r3VPiIGvZf1ZieRwi",   # alpha_password
        "disabled": False,
    }
}


# token class will return 2 data . this is same as OAuth2 actual model
# it will return access token and token type
class Token(BaseModel):
    access_token: str
    token_type: str


# TokenData class required 2 field.. you can add as per your requirement
class TokenData(BaseModel):
    username: str
    email: str


# User class required some fields
class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


# pwd_context is used to convert the password to hash type and vice versa
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# for OAuth2 you need to set tokenUrl endpoint
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


app = FastAPI()


# create a function to verify password
def verify_password(plain_password: str, hashed_password: str):
    # it will return a boolean value
    return pwd_context.verify(plain_password, hashed_password)


# create a function to convert the plain password to hash password
def get_password_hashed(plain_password):
    # it will convert the password to hashed and then it will return
    return pwd_context.hash(plain_password)


# get the user details from the fake DB and return the UserInDB object
def get_user(db, username: str):
    if username in db:
        user = db[username]
        return UserInDB(**user)


# create a function to authenticate user by providing their credentials
def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


# create access token
def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=10)
    to_encode.update({'exp': expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


# with the help of oauth2_scheme find out the current user
# the oauth2_scheme validate the credential and return user
async def get_current_user(token: str = Depends(oauth2_scheme)):
    credential_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get('sub')
        email: str = payload.get('email')
        if username is None:
            raise credential_exception
        # TokenData => this class required 2 fields data
        token_data = TokenData(username=username, email=email)
    except InvalidTokenError:
        raise credential_exception

    # get the user detail and return the user in response
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credential_exception
    return user


# check the user account is active or not
# it depends on the get_current_user .. ( from get_current_user you will get user details )
async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if current_user.disabled:
        raise HTTPException(
            status_code=400, detail="Inactive User"
        )
    return current_user


# you can create a rout to check user credential and return the access token as response
@app.post('/token')
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(fake_users_db, form_data.username, password=form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expire = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data=dict(
            sub=user.username,
            email=user.email
        ), expires_delta=access_token_expire
    )
    return Token(access_token=access_token, token_type="bearer")


# after authenticating user return the user data
@app.get("/user/me")
async def read_user_me(current_user: User = Depends(get_current_active_user)):
    return current_user


@app.get("/users/me/items")
async def read_own_item(current_user: User = Depends(get_current_active_user)):
    return [{'object': 'car'}, {'object': 'mobile'}, {'object': 'food'}, {'requested_user': current_user.username}]
